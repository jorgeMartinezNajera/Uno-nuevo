CREATE TABLE MEMBRESIA(
    ID_MEMBRESIA NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT MEMBRESIA_ID_MEMBRESIA_PK PRIMARY KEY,
    TIPO VARCHAR2(50)
        CONSTRAINT MEMBRESIA_TIPO_NN NOT NULL
        CONSTRAINT MEMBRESIA_TIPO_CHK CHECK(TIPO IN ('NORMAL','PLATINO','DIAMANTE'))
);

INSERT INTO membresia VALUES (3,'DIAMANTE');

CREATE TABLE CLIENTE(
    ID_CLIENTE NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT CLIENTE_ID_CLIENTE_PK PRIMARY KEY,
    NOMBRE_USUARIO VARCHAR(30)
        CONSTRAINT CLIENTE_NOMBRE_USUARIO_NN NOT NULL
        CONSTRAINT CLIENTE_NOMBRE_USUARIO_UK UNIQUE,
    METODO_PAGO NUMBER(16) -- Considera si este debe ser VARCHAR2 si puede tener ceros a la izquierda o caracteres no numéricos.
        CONSTRAINT CLIENTE_METODO_PAGO_UK UNIQUE
        CONSTRAINT CLIENTE_METODO_PAGO_NN NOT NULL,
    CONTRASENIA VARCHAR(20) -- Considera hashear las contraseñas en lugar de almacenarlas en texto plano.
        CONSTRAINT CLIENTE_CONTRASENIA_NN NOT NULL,
    NOMBRE VARCHAR2(50)
        CONSTRAINT CLIENTE_NOMBRE_NN NOT NULL,
    APELLIDO_PATERNO VARCHAR2(50)
        CONSTRAINT CLIENTE_APELLIDO_PATERNO_NN NOT NULL,
    APELLIDO_MATERNO VARCHAR2(50)
        CONSTRAINT CLIENTE_APELLIDO_MATERNO_NN NOT NULL,
    CORREO VARCHAR2(50)
        CONSTRAINT CIENTE_CORREO_UK UNIQUE
        CONSTRAINT CLIENTE_CORREO_NN NOT NULL,
    TELEFONO NUMBER(10) -- Considera VARCHAR2(10) si puede tener ceros a la izquierda.
        CONSTRAINT CLIENTE_TELEFONO_UK UNIQUE
        CONSTRAINT CLIENTE_TELEFONO_NN NOT NULL,
    ID_MEMBRESIA NUMBER(5)
        CONSTRAINT CLIENTE_MEMBRESIA_FK REFERENCES MEMBRESIA(ID_MEMBRESIA)
);

CREATE TABLE COMPRA(
    ID_COMPRA NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT COMPRA_ID_COMPRA_PK PRIMARY KEY,
    TOTAL NUMBER(5) -- Considera un tipo de dato NUMBER(p,s) si necesitas decimales, ej: NUMBER(10,2)
        CONSTRAINT COMPRA_TOTAL_NN NOT NULL
        CONSTRAINT COMPRA_TOTAL_CHK CHECK(TOTAL>0),
    FECHA DATE DEFAULT SYSDATE -- DEFAULT SYSDATE aquí es buena idea para la fecha de creación
        CONSTRAINT COMPRA_FECHA_NN NOT NULL
);

-- CLIENTE_COMPRA es una tabla de unión. Su clave primaria es compuesta por las FKs.
-- No suele tener un ID autoincremental propio a menos que tengas una razón específica.
CREATE TABLE CLIENTE_COMPRA(
    ID_CLIENTE NUMBER(5)
        CONSTRAINT CLIENTE_COMPRA_ID_CLIENTE_FK REFERENCES CLIENTE(ID_CLIENTE),
    ID_COMPRA NUMBER(5)
        CONSTRAINT CLIENTE_COMPRA_ID_COMPRA_FK REFERENCES COMPRA(ID_COMPRA)
        CONSTRAINT CLIENTE_COMPRA_ID_COMPRA_NN NOT NULL,
    CONSTRAINT CLIENTE_COMPRA_PK PRIMARY KEY (ID_CLIENTE, ID_COMPRA) -- Añadiendo una PK compuesta
);

-- ASIENTO.ID_ASIENTO es CHAR(3). No es candidato para autoincremento numérico.
-- Probablemente representa códigos como 'A01', 'B12', etc.
CREATE TABLE ASIENTO(
    ID_ASIENTO CHAR(3)
        CONSTRAINT ASIENTO_ID_ASIENTO_PK PRIMARY KEY,
    FILA NUMBER(2)
        CONSTRAINT ASIENTO_FILA_NN NOT NULL
        CONSTRAINT ASIENTO_FILA_CHK CHECK(FILA>0),
    COLUMNA CHAR(1)
        CONSTRAINT ASINETO_COLUMNA_NN NOT NULL -- Corregido: ASIENTO_COLUMNA_NN
);

INSERT INTO ASIENTO VALUES('A1',1,'A');
INSERT INTO ASIENTO VALUES('A2',2,'A');
INSERT INTO ASIENTO VALUES('A3',3,'A');
INSERT INTO ASIENTO VALUES('A4',4,'A');
INSERT INTO ASIENTO VALUES('A5',5,'A');
INSERT INTO ASIENTO VALUES('B1',1,'B');
INSERT INTO ASIENTO VALUES('B2',2,'B');
INSERT INTO ASIENTO VALUES('B3',3,'B');
INSERT INTO ASIENTO VALUES('B4',4,'B');
INSERT INTO ASIENTO VALUES('B5',5,'B');

-- TIPO_BOLETO.ID_TIPO es NUMBER(1). Podría ser un código (1=Adulto, 2=Niño).
-- Si es un código fijo, el autoincremento no es ideal. Si es solo un identificador, sí.
-- Lo haré autoincremental por si acaso, pero evalúa si es lo que necesitas.
CREATE TABLE TIPO_BOLETO(
    ID_TIPO NUMBER(1) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT TIPO_BOLETO_ID_TIPO PRIMARY KEY,
    PRECIO NUMBER(5,2) -- Aumentado para permitir precios como 999.99
        CONSTRAINT TIPO_BOLETO_PRECIO_NN NOT NULL
        CONSTRAINT TIPO_BOLERO_PRECIO_CHK CHECK(PRECIO>0) -- Corregido: TIPO_BOLETO_PRECIO_CHK
);

INSERT INTO TIPO_BOLETO VALUES(1,50);
INSERT INTO TIPO_BOLETO VALUES(2,100);
INSERT INTO TIPO_BOLETO VALUES(3,150);

CREATE TABLE SUCURSAL(
    ID_SUCURSAL NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT SUCURSAL_ID_SUCURSAL_PK PRIMARY KEY,
    CIUDAD VARCHAR2(50)
        CONSTRAINT SUCURSAL_CIUDAD_NN NOT NULL
);

INSERT INTO SUCURSAL VALUES (1,'Toluca');
INSERT INTO SALA VALUES (1, 'NORMAL', 1);
INSERT INTO SALA VALUES (2, 'NORMAL', 1);
INSERT INTO SALA VALUES (3, 'VIP', 1);
INSERT INTO SALA VALUES (4, 'NORMAL', 1);
INSERT INTO SALA VALUES (5, 'VIP', 1);

CREATE TABLE SALA(
    ID_SALA NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT SALA_ID_SALA_PK PRIMARY KEY,
    TIPO VARCHAR2(50)
        CONSTRAINT SALA_TIPO_NN NOT NULL
        CONSTRAINT SALA_TIPO_CHK CHECK(TIPO IN ('NORMAL','VIP')),
    ID_SUCURSAL NUMBER(5)
        CONSTRAINT SALA_ID_SUCURSAL_FK REFERENCES SUCURSAL(ID_SUCURSAL)
        CONSTRAINT SALA_ID_SUCURSAL_NN NOT NULL
);

CREATE TABLE PELICULA(
    ID_PELICULA NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT PELICULA_ID_PELICULA_PK PRIMARY KEY,
    NOMBRE VARCHAR2(50)
        CONSTRAINT PELICULA_NOMBRE_NN NOT NULL,
    RESUMEN VARCHAR2(500)
        CONSTRAINT PELICULA_RESUMEN_NN NOT NULL,
    CLASIFICACION CHAR(3) -- Asegúrate que los valores posibles para CHAR(3) estén definidos o validados en la aplicación.
        CONSTRAINT PELICULA_CLASIFICACION_NN NOT NULL,
    TRAILER BLOB, -- CONSTRAINT PELICULA_TRAILER_NN NOT NULL, (Puede ser NULL si no siempre hay trailer)
    DURACION NUMBER(3)
        CONSTRAINT PELICULA_DURACION_NN NOT NULL
        CONSTRAINT PELICULA_DURACION_CHK CHECK(DURACION>0),
    POSTER BLOB, -- CONSTRAINT PELICULA_POSTER_NN NOT NULL, (Puede ser NULL si no siempre hay poster)
    GENERO VARCHAR2(50)
        CONSTRAINT PELICULA_GENERO_NN NOT NULL
);

CREATE TABLE FUNCION(
    ID_FUNCION NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT FUNCION_ID_FUNCION_PK PRIMARY KEY,
    FECHA DATE DEFAULT SYSDATE
        CONSTRAINT FUNCION_FECHA_NN NOT NULL,
    HORA VARCHAR2(5) -- Considera usar un tipo de dato INTERVAL DAY TO SECOND o TIMESTAMP para la hora para mayor precisión y facilidad de manejo.
        CONSTRAINT FUNCION_HORA_NN NOT NULL,
    ASIENTOS_DISPONIBLES NUMBER(3)
        CONSTRAINT FUNCION_ASIENTOS_DISPONIBLES_NN NOT NULL
        CONSTRAINT FUNCION_ASIENTOS_DISPONIBLES_CHK CHECK(ASIENTOS_DISPONIBLES >= 0 AND ASIENTOS_DISPONIBLES <= 200), 
    ID_SALA NUMBER(5)
        CONSTRAINT FUNCION_ID_SALA_FK REFERENCES SALA(ID_SALA)
        CONSTRAINT FUNCION_ID_SALA_NN NOT NULL,
    ID_PELICULA NUMBER(5) CONSTRAINT FUNCION_ID_PELICULA_FK  -- SE AGREGO EL ID DE LA PELICULA 
    REFERENCES PELICULA(ID_PELICULA)
    CONSTRAINT FUNCION_ID_PELICULA_NN NOT NULL
);

INSERT INTO FUNCION VALUES (1, DEFAULT, '9:00', 10, 1, 1);
INSERT INTO FUNCION VALUES (2, DEFAULT, '11:00', 10, 1, 1);
INSERT INTO FUNCION VALUES (3, DEFAULT, '11:00', 10, 3, 1);
SELECT * FROM FUNCION WHERE ID_PELICULA = '1';


SELECT F.HORA, F.ID_SALA, S.TIPO
FROM FUNCION F
LEFT JOIN SALA S ON F.ID_SALA = S.ID_SALA
WHERE F.ID_PELICULA = '1';


SELECT F.HORA, F.ID_SALA, S.TIPO
FROM FUNCION F
JOIN SALA S ON F.ID_SALA = S.ID_SALA
WHERE F.ID_PELICULA = '1';


CREATE TABLE FUNCION_ASIENTO(
    ID_FUNCION NUMBER(5)
        CONSTRAINT FUNCION_ASIENTO_ID_FUNCION_FK REFERENCES FUNCION(ID_FUNCION)
        CONSTRAINT FUNCION_ASIENTO_ID_FUNCION_NN NOT NULL,
    ID_ASIENTO CHAR(3)
        CONSTRAINT FUNCION_ID_ASIENTO_FK REFERENCES ASIENTO(ID_ASIENTO)
        CONSTRAINT FUNCION_ID_ASIENTO_NN NOT NULL,
    CONSTRAINT FUNCION_ASIENTO_PK PRIMARY KEY (ID_FUNCION, ID_ASIENTO) -- Añadiendo una PK compuesta
);

CREATE TABLE BOLETO(
    ID_BOLETO NUMBER(5) GENERATED BY DEFAULT AS IDENTITY
        CONSTRAINT BOLETO_ID_BOLETO_PK PRIMARY KEY,
    DESCUENTO NUMBER(1)
        CONSTRAINT BOLETO_DESCUENTO_NN NOT NULL,
    CONSTRAINT BOLETO_DESCUENTO_CHK CHECK(DESCUENTO IN (0,1)), -- 0 para no descuento, 1 para sí descuento.
    ID_SUCURSAL NUMBER(5)
        CONSTRAINT BOLETO_ID_SUCURSAL_FK REFERENCES SUCURSAL(ID_SUCURSAL)
        CONSTRAINT BOLETO_ID_SUCURSAL_NN NOT NULL,
    ID_PELICULA NUMBER(5)
        CONSTRAINT BOLETO_ID_PELICULA_FK REFERENCES PELICULA(ID_PELICULA)
        CONSTRAINT BOLETO_ID_PELICULA_NN NOT NULL, -- Corregido: BOLETO_ID_PELICULA_NN
    ID_SALA NUMBER(5)
        CONSTRAINT BOLETO_ID_SALA_FK REFERENCES SALA(ID_SALA)
        CONSTRAINT BOLETO_ID_SALA_NN NOT NULL,
    ID_ASIENTO CHAR(3)
        CONSTRAINT BOLETO_ID_ASIENTO_FK REFERENCES ASIENTO(ID_ASIENTO)
        CONSTRAINT BOLETO_ID_ASIENTO_NN NOT NULL,
    ID_COMPRA NUMBER(5)
        CONSTRAINT BOLETO_ID_COMPRA_FK REFERENCES COMPRA(ID_COMPRA) -- Corregido: BOLETO_ID_COMPRA_FK
        CONSTRAINT BOLETO_ID_COMPRA_NN NOT NULL,
    ID_FUNCION NUMBER(5)
        CONSTRAINT BOLETO_ID_FUNCION_FK REFERENCES FUNCION(ID_FUNCION)
        CONSTRAINT BOLETO_ID_FUNCION_NN NOT NULL,
    ID_TIPO_BOLETO NUMBER(1)
        CONSTRAINT BOLETO_ID_TIPO_BOLETO_FK REFERENCES TIPO_BOLETO(ID_TIPO)
        CONSTRAINT BOLETO_ID_TIPO_BOLETO_NN NOT NULL
);

-- Tus sentencias DROP (tal como las proporcionaste)
-- Es buena práctica ejecutar los DROP en orden inverso a la creación
-- o teniendo en cuenta las dependencias si no usas CASCADE CONSTRAINTS en todos.
DROP TABLE CLIENTE_COMPRA;
DROP TABLE FUNCION_ASIENTO;
 DROP TABLE BOLETO;
DROP TABLE FUNCION;
DROP TABLE CLIENTE;
DROP TABLE MEMBRESIA;
DROP TABLE COMPRA;
DROP TABLE ASIENTO;
DROP TABLE TIPO_BOLETO;
DROP TABLE SALA;
DROP TABLE PELICULA;
DROP TABLE SUCURSAL;

-- Si quieres dropear todo y tienes las referencias bien definidas,
-- puedes dropear las tablas "padre" al final.
-- Por ejemplo, SUCURSAL, MEMBRESIA, PELICULA, ASIENTO, TIPO_BOLETO, COMPRA
-- serían de las últimas en ser eliminadas si otras tablas las referencian.
-- Los `DROP TABLE ... CASCADE CONSTRAINTS;` eliminan la tabla y cualquier restricción de integridad
-- que dependa de las claves únicas o primarias de la tabla eliminada.

-- Ejemplo de un orden de DROP más seguro (sin CASCADE CONSTRAINTS para las FK que apuntan a otras tablas):
DROP TABLE CLIENTE_COMPRA;
DROP TABLE FUNCION_ASIENTO;
DROP TABLE BOLETO;
DROP TABLE CLIENTE; -- Depende de MEMBRESIA
DROP TABLE FUNCION; -- Depende de SUCURSAL, PELICULA, SALA
DROP TABLE SALA; -- Depende de SUCURSAL
DROP TABLE MEMBRESIA;
DROP TABLE COMPRA;
DROP TABLE ASIENTO;
DROP TABLE TIPO_BOLETO;
DROP TABLE PELICULA;
DROP TABLE SUCURSAL;


-- O usando CASCADE CONSTRAINTS como tenías para CLIENTE y MEMBRESIA, lo que simplifica el orden:
DROP TABLE CLIENTE CASCADE CONSTRAINTS;
DROP TABLE MEMBRESIA CASCADE CONSTRAINTS;
 DROP TABLE COMPRA CASCADE CONSTRAINTS; -- Añadido CASCADE
DROP TABLE CLIENTE_COMPRA; -- Ya no es necesario si COMPRA y CLIENTE usan CASCADE
DROP TABLE ASIENTO CASCADE CONSTRAINTS;
DROP TABLE TIPO_BOLETO CASCADE CONSTRAINTS;
DROP TABLE SUCURSAL CASCADE CONSTRAINTS;
DROP TABLE SALA CASCADE CONSTRAINTS;
DROP TABLE PELICULA CASCADE CONSTRAINTS;
DROP TABLE FUNCION CASCADE CONSTRAINTS;
DROP TABLE FUNCION_ASIENTO; -- Ya no es necesario si FUNCION y ASIENTO usan CASCADE
DROP TABLE BOLETO CASCADE CONSTRAINTS;